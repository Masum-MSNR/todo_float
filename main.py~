import tkinter as tk
from tkinter.simpledialog import askstring
import pickle
import os
from datetime import datetime

from tkinter import PhotoImage

class FloatingWidget:
    def __init__(self, root):
        self.root = root
        self.root.geometry("300x400+1000+10")  # Adjusted size to make space for both buttons and list
        self.root.configure(bg="black")
        self.root.wm_attributes("-alpha", 0.8)  # Transparency (0.0 to 1.0)
        self.root.overrideredirect(True)  # Remove window borders
        self.root.wm_attributes("-topmost", True)  # Default Always on top

        # Create a canvas widget for the to-do list and a scrollbar
        self.canvas = tk.Canvas(self.root, bg="black")
        self.scrollbar = tk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        # Create a frame to hold the list of to-dos
        self.todo_frame = tk.Frame(self.canvas, bg="black")
        self.canvas.create_window((0, 0), window=self.todo_frame, anchor="nw")

        # Bind the scrollbar to the canvas
        self.scrollbar.pack(side="right", fill="y")
        self.canvas.pack(side="top", fill="both", expand=True)

        # Load saved to-dos
        self.todos = self.load_todos()

        # Display saved to-dos
        self.update_todo_list()

        # Frame for buttons at bottom
        button_frame = tk.Frame(self.root, bg="black")
        button_frame.pack(side="bottom", fill="x")

        # Toggle Always on Top button
        self.toggle_button = tk.Button(button_frame, text="Turn OFF Always On Top", command=self.toggle_on_top,
                                       bg="blue", fg="white")
        self.toggle_button.pack(side="left", fill="both", expand=True)

        # Add To-Do button
        self.add_todo_button = tk.Button(button_frame, text="Add To-Do", command=self.add_todo, bg="green", fg="white")
        self.add_todo_button.pack(side="left", fill="both", expand=True)

        # Update scroll region after adding or removing items
        self.todo_frame.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))

        # Dragging feature
        self.root.bind("<ButtonPress-1>", self.start_move)
        self.root.bind("<B1-Motion>", self.on_move)
        self.root.bind("<ButtonRelease-1>", self.stop_move)

        # Set daily reset time at 6 AM
        self.reset_time = "06:00:00"
        self.check_reset_time()

    def check_reset_time(self):
        """Check and reset the checkbox states at 6 AM every day"""
        current_time = datetime.now()
        reset_time_today = datetime.strptime(f"{current_time.date()} {self.reset_time}", "%Y-%m-%d %H:%M:%S")

        if current_time >= reset_time_today:
            self.reset_checkboxes()

    def reset_checkboxes(self):
        """Reset all checkbox states to unchecked at 6 AM"""
        for todo in self.todos:
            todo['checked'] = False
            todo['var'].set(0)  # Reset the IntVar

        self.save_todos()
        self.update_todo_list()

    def toggle_on_top(self):
        """Toggle the Always On Top property"""
        if self.root.wm_attributes("-topmost"):
            self.root.wm_attributes("-topmost", False)
            self.toggle_button.config(text="Turn ON Always On Top")
        else:
            self.root.wm_attributes("-topmost", True)
            self.toggle_button.config(text="Turn OFF Always On Top")

    def add_todo(self):
        """Open a window to add a To-Do item"""
        todo_text = askstring("To-Do", "Enter your task:", parent=self.root)
        if todo_text:
            todo = {'task': todo_text, 'checked': False, 'var': tk.IntVar(value=0)}  # Unchecked by default
            self.todos.append(todo)
            self.save_todos()
            self.update_todo_list()


    def update_todo_list(self):
        """Update the To-Do list display"""
        # Remove existing widgets in the todo_frame to update UI
        for widget in self.todo_frame.winfo_children():
            widget.destroy()

        # Create the list with colored rectangles
        for i, todo in enumerate(self.todos):
            todo_frame = tk.Frame(self.todo_frame, bg="black")
            todo_frame.pack(fill="x", pady=2, anchor="w")  # Ensure left alignment and full width

            # Ensure that 'var' is set for each todo item
            if 'var' not in todo:
                todo['var'] = tk.IntVar(value=0)  # Default unchecked state (0)

            # Canvas to draw the colored rectangle
            canvas = tk.Canvas(todo_frame, width=20, height=20, bg="red", bd=0, highlightthickness=0)
            canvas.pack(side="left", padx=5, anchor="w")

            # Set the color based on the checked state (green for checked, red for unchecked)
            if todo['checked']:
                canvas.config(bg="green")  # Green when checked
            else:
                canvas.config(bg="red")  # Red when unchecked

            # Bind click event to toggle the state when the rectangle is clicked
            canvas.bind("<Button-1>", lambda event, idx=i: self.toggle_rectangle(idx))

            # Text label for the task, which should take the remaining space
            label = tk.Label(todo_frame, text=todo['task'], fg="white", bg="black", font=("Arial", 10), anchor="w",width= 23)
            label.pack(side="left", fill="x", padx=10, anchor="w")

            # Load and scale delete icon
            delete_icon = PhotoImage(file="delete_icon.png")  # Provide path to your image here
            delete_icon = delete_icon.subsample(12, 12)  # Resize to appropriate size (adjust the scaling factor)

            # Create a label to hold the delete icon with fixed size
            delete_label = tk.Label(todo_frame, image=delete_icon, bg="black", width=20,

                                    height=20)  # Set width and height
            delete_label.photo = delete_icon  # Store reference to avoid garbage collection
            delete_label.pack(side="right", padx=5)

            # Bind click event to delete the to-do when the icon is clicked
            delete_label.bind("<Button-1>", lambda event, idx=i: self.delete_todo(idx))

            # Update the scroll region after adding or removing items
            self.todo_frame.update_idletasks()
            self.canvas.config(scrollregion=self.canvas.bbox("all"))

    def toggle_rectangle(self, idx):
        """Toggle the state when the colored rectangle is clicked"""
        todo = self.todos[idx]
        todo['checked'] = not todo['checked']  # Toggle the checked state

        # Update the color of the rectangle based on the new state
        self.update_single_rectangle(idx)

        # Save the updated to-dos
        self.save_todos()

    def update_single_rectangle(self, idx):
        """Update only the rectangle widget without refreshing the entire list"""
        todo = self.todos[idx]
        todo_frame = self.todo_frame.winfo_children()[idx]

        # Find the canvas (rectangle) in the todo_frame
        for widget in todo_frame.winfo_children():
            if isinstance(widget, tk.Canvas):
                # Change the color based on the checked state
                if todo['checked']:
                    widget.config(bg="green")  # Green for checked
                else:
                    widget.config(bg="red")  # Red for unchecked

    def delete_todo(self, idx):
        """Delete a to-do from the list"""
        del self.todos[idx]
        self.save_todos()
        self.update_todo_list()

    def save_todos(self):
        """Save the current to-dos to a local file (excluding IntVar)"""
        serializable_todos = [{'task': todo['task'], 'checked': todo['checked']} for todo in self.todos]
        with open("todos.pkl", "wb") as f:
            pickle.dump(serializable_todos, f)

    def load_todos(self):
        """Load saved to-dos from a local file, handling empty or corrupt files."""
        if os.path.exists("todos.pkl"):
            try:
                with open("todos.pkl", "rb") as f:
                    if os.path.getsize("todos.pkl") > 0:  # Check if file is not empty
                        todos = pickle.load(f)
                        # Ensure that 'var' is set for each todo loaded from file
                        for todo in todos:
                            if 'var' not in todo:
                                # Correctly initialize 'var' based on 'checked' state
                                todo['var'] = tk.IntVar(value=1 if todo['checked'] else 0)
                        return todos
            except (EOFError, pickle.UnpicklingError):  # Handle empty/corrupt file
                return []
        return []

    def start_move(self, event):
        """Record the initial position for dragging"""
        self.x = event.x
        self.y = event.y

    def on_move(self, event):
        """Move the window while dragging"""
        self.root.geometry(f"+{event.x_root - self.x}+{event.y_root - self.y}")

    def snap_to_corner(self):
        """Snap the floating widget to the nearest corner"""
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()

        win_x = self.root.winfo_x()
        win_y = self.root.winfo_y()
        win_width = 300  # Your window width
        win_height = 400  # Your window height

        # Determine closest corner
        corners = {
            "top-left": (0, 0),
            "top-right": (screen_width - win_width, 0),
            "bottom-left": (0, screen_height - win_height),
            "bottom-right": (screen_width - win_width, screen_height - win_height)
        }

        # Find the closest corner
        closest_corner = min(corners, key=lambda c: (abs(win_x - corners[c][0]) + abs(win_y - corners[c][1])))

        # Move window to closest corner
        self.root.geometry(f"+{corners[closest_corner][0]}+{corners[closest_corner][1]}")

    def stop_move(self, event):
        """Snap the window to the nearest corner when user stops dragging"""
        self.snap_to_corner()


root = tk.Tk()
app = FloatingWidget(root)
root.mainloop()
